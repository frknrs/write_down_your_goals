mod db;
use actix_files as fs;
use actix_web::{get, post, web, App, HttpResponse, HttpServer, Responder, Result};
use db::*;
use serde::Deserialize;
use serde_json::json;

// Serve the index.html file
async fn index() -> Result<fs::NamedFile, actix_web::Error> {
    fs::NamedFile::open("static/index.html").map_err(actix_web::error::ErrorInternalServerError)
}

#[derive(Deserialize)]
pub struct NewGoal {
    pub text: String,
}

// Endpoint to add a new goal
#[post("/add_goal")]
async fn add_goal(
    pool: web::Data<sqlx::SqlitePool>, // Adjusted to use the pool from the application state
    goal: web::Json<NewGoal>,
) -> Result<HttpResponse, actix_web::Error> {
    match create_table_with_pool(&pool).await {
        Ok(_) => {}
        Err(err) => {
            println!("Error while creating the table: {}", err);
            return Err(actix_web::error::ErrorInternalServerError(err));
        }
    }

    let new_goal = Goal {
        id: 0, // This is a placeholder, as the actual ID is generated by the database.
        date: get_date(),
        text: goal.text.clone(),
    };

    // Add the goal to the database using the add_goal method
    match new_goal.insert_goal(pool.get_ref()).await {
        Ok(_) => Ok(HttpResponse::Ok().json(json!({"message": "Goal added successfully!"}))),
        Err(err) => {
            println!("Error adding goal: {}", err);
            Err(actix_web::error::ErrorInternalServerError(err))
        }
    }
}

// Endpoint to retrieve all goals
#[get("/get_goals")]
async fn get_goals(pool: web::Data<sqlx::SqlitePool>) -> Result<HttpResponse, actix_web::Error> {
    match get_all_goals_with_pool(&pool).await {
        Ok(goals) => Ok(HttpResponse::Ok().json(goals)),
        Err(err) => {
            println!("Error getting goals: {}", err);
            Err(actix_web::error::ErrorInternalServerError(err))
        }
    }
}

// Endpoint to clear the database table
#[get("/clean_table")]
async fn clean_database(pool: web::Data<sqlx::SqlitePool>) -> impl Responder {
    match clean_table(&pool).await {
        Ok(_) => Ok(HttpResponse::Ok().json("Table cleared successfully")),
        Err(e) => {
            println!("Error clearing the table: {}", e);
            Err(actix_web::error::ErrorInternalServerError(e))
        }
    }
}

// Main function to start the HTTP server
#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Initialize the connection pool
    let pool = db::connect_to_db().await.expect("Failed to create pool.");

    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(pool.clone())) // Updated to use .app_data
            .route("/", web::get().to(index))
            .service(add_goal)
            .service(get_goals)
            .service(clean_database)
            .service(fs::Files::new("/static", "static").show_files_listing())
    })
    .bind("127.0.0.1:8090")?
    .run()
    .await
}
